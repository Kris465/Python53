### **Конспект лекции: Функции в Python (`def`)**

**Тема:** 1.7 Функции в Python (`def`).
**Цель:** Научиться структурировать код с помощью функций: объявлять, вызывать, передавать в них данные и возвращать результаты. Понять область видимости переменных.

---

## **Введение в функции**

**Функция** — это именованный блок кода, который выполняет определенную задачу и может быть многократно вызван из разных частей программы.

**Зачем нужны функции?**
*   **Устранение дублирования кода:** Если одна и та же операция повторяется, ее можно вынести в функцию.
*   **Структурирование и читаемость:** Код разбивается на логические блоки, его легче понимать и поддерживать.
*   **Упрощение отладки:** Легче найти ошибку в одном месте (в функции), чем в десятках копий одного кода.
*   **Сокрытие сложности:** Можно использовать сложную логику, просто вызывая функцию, не вникая в ее внутреннее устройство.

**Аналогия из жизни:**
Кофемашина. Вы нажимаете одну кнопку ("вызываете функцию"), и внутри происходит множество действий: помол кофе, нагрев воды, приготовление напитка. Вам не нужно знать внутренний процесс, вы просто получаете результат.

---

## **Объявление и вызов функций. Ключевое слово `def`**

### **Объявление функции (создание)**

Для объявления функции используется ключевое слово **`def`**.

```python
def имя_функции():
    # Тело функции
    # Блок кода, который выполняется при вызове
    действие1
    действие2
```

**Пример 1: Простая функция-приветствие**
```python
# Объявление функции
def greet():
    print("Привет, мир!")
    print("Добро пожаловать в Python!")

# Функция объявлена, но еще не выполнена.
```

### **Вызов функции (запуск)**

Чтобы код внутри функции выполнился, функцию необходимо **вызвать** по имени, добавив круглые скобки.

```python
# Вызов функции greet()
greet()
```
**Вывод:**
```
Привет, мир!
Добро пожаловать в Python!
```

**Пример 2: Функция с повторным использованием**
```python
def print_separator():
    print("-" * 30) # Напечатает строку из 30 дефисов

print("Важный заголовок")
print_separator()    # Первый вызов
print("Текст первого раздела")
print_separator()    # Второй вызов
print("Текст второго раздела")
print_separator()    # Третий вызов
```
**Вывод:**
```
Важный заголовок
------------------------------
Текст первого раздела
------------------------------
Текст второго раздела
------------------------------
```

---

## **Параметры и аргументы**

Функции становятся по-настоящему мощными, когда мы можем передавать в них данные для обработки.

### **Параметры vs Аргументы**

*   **Параметр** — это переменная, указанная в скобках при **объявлении** функции.
*   **Аргумент** — это конкретное значение, которое передается функции при ее **вызове**.

### **Функция с одним параметром**

```python
# Объявление: 'name' — это параметр
def greet_user(name):
    print(f"Привет, {name}! Рады тебя видеть!")

# Вызовы: "Дипсик" и "Анна" — это аргументы
greet_user("Дипсик") # Передаем строку "Дипсик"
greet_user("Анна")   # Передаем строку "Анна"
```
**Вывод:**
```
Привет, Дипсик! Рады тебя видеть!
Привет, Анна! Рады тебя видеть!
```

### **Функция с несколькими параметрами**

```python
# Объявление: 'a' и 'b' — параметры
def add_numbers(a, b):
    result = a + b
    print(f"Сумма {a} и {b} равна {result}")

# Вызовы
add_numbers(5, 3)       # 5 и 3 — аргументы
add_numbers(10, -2)     # 10 и -2 — аргументы
```
**Вывод:**
```
Сумма 5 и 3 равна 8
Сумма 10 и -2 равна 8
```

### **Различные типы аргументов**

```python
def describe_pet(animal_type, pet_name):
    """Выводит информацию о животном."""
    print(f"\nУ меня есть {animal_type}.")
    print(f"Его зовут {pet_name.title()}.")

# Позиционные аргументы (порядок важен)
describe_pet("хомяк", "барашек")
describe_pet("собака", "шарик") 

# Именованные аргументы (порядок не важен)
describe_pet(pet_name="мурзик", animal_type="кот")
```

---

## **Возврат значения. Ключевое слово `return`**

Функция может не только выводить что-то на экран (`print`), но и возвращать результат своей работы для дальнейшего использования. Для этого служит ключевое слово **`return`**.

*   Оператор `return` завершает выполнение функции и отправляет значение обратно в то место, откуда ее вызвали.
*   Если после `return` есть другие строки кода в функции, они выполнены не будут.
*   Функция без `return` возвращает специальное значение `None`.

### **Возврат одного значения**

```python
# Объявление функции
def square(number):
    """Возвращает квадрат числа."""
    squared_value = number ** 2
    return squared_value # Возвращаем результат

# Вызов и сохранение результата
my_number = 5
my_square = square(my_number) # Значение return присваивается в my_square
print(f"Квадрат числа {my_number} равен {my_square}") # Квадрат числа 5 равен 25

# Вызов прямо в print или выражении
print(square(3)) # 9
print(square(4) + square(3)) # 16 + 9 = 25
```

### **Возврат нескольких значений (через кортеж)**

```python
def swap(a, b):
    """Меняет местами два значения."""
    return b, a # Возвращается кортеж (b, a)

x = 10
y = 20
print(f"До: x={x}, y={y}") # До: x=10, y=20

x, y = swap(x, y) # Распаковываем кортеж обратно в переменные
print(f"После: x={x}, y={y}") # После: x=20, y=10

# Или так (менее читаемо):
# result = swap(x, y)
# x = result[0]
# y = result[1]
```

### **`return` без значения vs с `None`**

```python
def function_with_return():
    print("Что-то делаем...")
    return # Явный возврат None

def function_without_return():
    print("Что-то делаем...")
    # Неявный возврат None

result1 = function_with_return()
result2 = function_without_return()

print(result1) # None
print(result2) # None
```

---

## **Область видимости переменных (Scope)**

**Область видимости** — это часть программы, в которой можно обратиться к переменной.

### **Локальные переменные**

*   Создаются **внутри функции**.
*   Видны и доступны **только внутри этой функции**.

```python
def my_function():
    local_var = "Я локальная переменная" # Локальная переменная
    print(local_var) # Работает

my_function()
# print(local_var) # ОШИБКА! NameError: name 'local_var' is not defined
```

### **Глобальные переменные**

*   Создаются **в основном теле программы** (не внутри функций/классов).
*   Видны и доступны **из любой части кода**, включая функции (но для изменения есть нюансы).

```python
global_var = "Я глобальная переменная" # Глобальная переменная

def show_global():
    print(global_var) # Мы можем ЧИТАТЬ глобальную переменную внутри функции

show_global() # Я глобальная переменная
print(global_var) # Я глобальная переменная
```

### **Изменение глобальных переменных внутри функции**

Чтобы изменить глобальную переменную внутри функции, нужно использовать ключевое слово **`global`**.

```python
counter = 0 # Глобальная переменная

def increment():
    global counter # Объявляем, что будем использовать глобальную 'counter'
    counter += 1
    print(f"Счетчик внутри функции: {counter}")

print(f"Счетчик до вызова: {counter}") # Счетчик до вызова: 0
increment() # Счетчик внутри функции: 1
increment() # Счетчик внутри функции: 2
print(f"Счетчик после вызовов: {counter}") # Счетчик после вызовов: 2
```

**Важно:** Чрезмерное использование `global` считается плохой практикой, так как усложняет понимание кода и отслеживание ошибок. Лучше передавать данные через параметры и возвращать результаты.

---

## **Практические примеры**

### **Пример 1: Калькулятор площадей**

```python
def calculate_rectangle_area(length, width):
    """Вычисляет площадь прямоугольника."""
    return length * width

def calculate_triangle_area(base, height):
    """Вычисляет площадь треугольника."""
    return 0.5 * base * height

# Использование
room_area = calculate_rectangle_area(5, 4)
print(f"Площадь комнаты: {room_area} кв.м.") # Площадь комнаты: 20 кв.м.

plot_area = calculate_triangle_area(10, 8)
print(f"Площадь участка: {plot_area} кв.м.") # Площадь участка: 40 кв.м.
```

### **Пример 2: Проверка пароля**

```python
def is_strong_password(password):
    """Проверяет, является ли пароль надежным."""
    if len(password) < 8:
        return False
    if not any(char.isdigit() for char in password):
        return False
    if not any(char.isupper() for char in password):
        return False
    return True

# Использование
user_password = input("Введите пароль: ")
if is_strong_password(user_password):
    print("Пароль надежный!")
else:
    print("Пароль слабый. Используйте не менее 8 символов, цифры и заглавные буквы.")
```

### **Пример 3: Генератор билетов**

```python
def create_ticket(event, seat, price):
    """Генерирует отформатированную информацию о билете."""
    separator = "=" * 30
    ticket_info = f"""
{separator}
    БИЛЕТ НА {event.upper()}
{separator}
    Место: {seat}
    Цена: {price} руб.
{separator}
"""
    return ticket_info

# Использование
my_ticket = create_ticket("Концерт", "A12", 2500)
print(my_ticket)
```
**Вывод:**
```
==============================
    БИЛЕТ НА КОНЦЕРТ
==============================
    Место: A12
    Цена: 2500 руб.
==============================
```

---

## **Распространенные ошибки**

### **1. Вызов функции до ее объявления**

```python
# НЕПРАВИЛЬНО:
greet() # NameError: name 'greet' is not defined

def greet():
    print("Привет!")
```

### **2. Путаница в количестве аргументов**

```python
def greet_user(first_name, last_name):
    print(f"Привет, {first_name} {last_name}!")

# НЕПРАВИЛЬНО:
# greet_user("Дипсик") # TypeError: missing required argument 'last_name'
```

### **3. Ожидание, что функция изменяет аргумент (для неизменяемых типов)**

```python
def increment(number):
    number += 1
    return number

my_var = 5
increment(my_var)
print(my_var) # 5 (не изменилось!), потому что number - локальная копия

# ПРАВИЛЬНО:
my_var = increment(my_var) # Нужно перезаписать
print(my_var) # 6
```

### **4. Использование локальной переменной вне функции**

```python
def my_func():
    secret = 42

# print(secret) # ОШИБКА! NameError: name 'secret' is not defined
```

---

## **Итоги урока**

### **Ключевые моменты:**
*   **`def`** — ключевое слово для объявления функции.
*   **Параметры** — переменные функции; **аргументы** — фактические значения.
*   **`return`** — возвращает результат и завершает функцию.
*   **Локальные переменные** живут внутри функции, **глобальные** — во всей программе.
*   Для изменения глобальной переменной используется `global` (но лучше избегать).

### **Практические рекомендации:**
1.  Давайте функциям понятные, описательные имена.
2.  Используйте **docstrings** (строки документации в тройных кавычках) для описания назначения функции.
3.  Функция должна выполнять одну четкую задачу.
4.  Предпочитайте возврат значений через `return` вместо вывода на печать (`print`) внутри функций, если только вывод не является их основной целью.
5.  Старайтесь не полагаться на глобальные переменные. Передавайте данные через параметры.

### **Типичные сценарии применения:**
*   **Вынесение повторяющегося кода**
*   **Разбиение сложной задачи на простые шаги**
*   **Создание библиотек утилит** (например, для работы с математикой, строками, данными)
*   **Организация кода в больших проектах**